#1. AVL树

　　AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O（log n）。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。

　　节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要**重新平衡**这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。

##１.２AVL旋转

　　AVL树的基本操作一般涉及运作同在不平衡的二叉查找树所运作的同样的算法。但是要进行预先或随后做一次或多次所谓的"AVL旋转"。

　　以下图表以 **四列** 表示四种情况，每行表示在该种情况下要进行的操作。在左左和右右的情况下，只需要进行一次旋转操作；在左右和右左的情况下，需要进行两次旋转操作。

> Root是失去平衡树的根节点，Pivot是旋转后重新平衡树的根节点

![这里写图片描述](http://img.blog.csdn.net/20160612143136956)

 - 插入

　向AVL树插入，可以透过如同它是未平衡的二叉查找树一样，把给定的值插入树中，接着自底往上向根节点折回，于在插入期间成为不平衡的所有节点上进行旋转来完成。

 - 删除

　从AVL树中删除，可以透过把要删除的节点向下旋转成一个叶子节点，接着直接移除这个叶子节点来完成。

 - 搜寻

　可以像普通二叉查找树一样的进行，所以耗费O(log n)时间，因为AVL树总是保持平衡的。

##１.３AVL节点数计算

高度为h的AVL树，节点数N最多 ![这里写图片描述](https://wikimedia.org/api/rest_v1/media/math/render/svg/f933ccc9d17f70cd03d6aa6fbf61b34a0d47ff62)。

![这里写图片描述](http://img.blog.csdn.net/20160612143832921)　

想起了什么？　Fibonacci 是不是．．．可以根据节点数ｎ求出相应的高度ｈ。


#2.哈夫曼树

　　哈夫曼树又称最优二叉树，是一种**带权路径长度最短的二叉树**。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的 路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。

　　树的带权路径长度记为WPL= (W1*L1+W2*L2+W3*L3+...+Wn*Ln)，N个权值Wi(i=1,2,...n)构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li(i=1,2,...n)。可以证明哈夫曼树的WPL是最小的。

#2.1哈夫曼树的构造

 　　假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：
 　　
①　将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；

②在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；

③从森林中删除选取的两棵树，并将新树加入森林；

④重复②、③步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。

#2.２哈夫曼编码

　　哈夫曼编码是可变字长编码(VLC)的一种。该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码。

![这里写图片描述](http://img.blog.csdn.net/20160612151017097)　

> 有A,B,C,D,E五个字符，出现的频率（即权值）分别为5,4,3,2,1，对其进行哈夫曼编码。

首先把A,B,C,D,E构造成一棵哈夫曼树（２.１有说明）；

通过从哈夫曼树根结点开始，对左子树分配代码“0”，右子树分配代码“1”，一直到达叶子结点为止，然后将从树根沿每条路径到达叶子结点的代码排列起来，便得到了哈夫曼编码。

![这里写图片描述](http://img.blog.csdn.net/20160612151250872)　

所以各字符对应的编码为：A->11,B->10,C->00,D->011,E->010

霍夫曼编码是一种无前缀编码。解码时不会混淆。其主要应用在数据压缩，加密解密等场合。