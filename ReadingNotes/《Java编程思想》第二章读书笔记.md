#《Java编程思想第二章》
---

##一切都是对象

###对象存放位置与生命周期

C++创建的对象可以存放在栈、静态存储区与堆（heap）中，放在栈中的对象用完后不需手动释放，会自动销毁，但放在堆中的对象需手动释放，栈中的对象所需空间与生命周期都是确定的，堆中的对象内存分配是动态的，在运行时才知道需要多少内存以及生命周期，如果说在堆上创建对象，编译器就会对它的生命周期一无所知，C++就需要以编程的方式来确定何时销毁对象，这可能因不正确处理而导致内存泄漏，而Java则提供了自动垃圾回收机制。

Java对象的创建采用了动态内存分配策略，即创建的堆都是放在堆中的。

###数据内存分配

寄存器——位于处理器内部，这是最快的存储区，大小极其有限，一般不能直接控制，但C和C++允许你向编译器建议寄存器分配方式。

堆栈——位于通用RAM（随机访问存储器）中，堆栈指针向下移动，则分配新的内存；若向上移动，则释放内存。这是一种快速有效的分配方法，速度仅次于寄存器。创建程序时，Java系统必须知道存储在堆栈内所有项的确切生命周期，以便上下移动堆栈指针。这一约束限制了程序的灵活性，所以虽然某些Java数据存储于堆栈中（如对象引用），但是Java对象并不存储于其中。

堆——一种通用的内存池（也位于RAM区），用于存放所有的Java对象，堆不同于堆栈的好处是，编译器不需要知道存储的数据在堆里存活多长时间。因此，在堆栈分配存储有很大的灵活性。当然，这种灵活性导致了分配需要更多的时间，时间效率上不如堆栈。

常量存储：常量值通常直接存放到程序代码内部，这样做是安全的，因为它们永远不会被改变。

非RAM存储：数据可完全存活于程序之外，在没有运行机制时也可以存在，如持久化对象的存放。

JVM有两类存储区：常量缓冲池和方法区。常量缓冲池用于存储类名称、方法和字段名称以及串常量。方法区则用于存储Java方法的字节码。

Java字节码的执行有两种方式：

1. 即时编译方式：解释器先将字节码编译成机器码，然后再执行该机器码。
2. 解释执行方式：解释器通过每次解释并执行一小段代码来完成Java字节码程 序的所有操作。

通常采用的是第二种方法。由于JVM规格描述具有足够的灵活性，这使得将字节码翻译为机器代码的工作具有较高的效率。对于那些对运行速度要求较高的应用程序，解释器可将Java字节码即时编译为机器码，从而很好地保证了Java代码的可移植性和高性能。

###基本类型

void属于基本类型，但只能用来修饰方法，不能用来修饰变量。

* 只要两个操作数中有一个是double类型的，另一个将会被转换成double类型，并且结果也是double类型；

* 否则，只要两个操作数中有一个是float类型的，另一个将会被转换成float类型，并且结果也是float类型；

* 否则，只要两个操作数中有一个是long类型的，另一个将会被转换成long类型，并且结果也是long类型；

* 否则，两个操作数（包括byte、short、int、char）都将会被转换成int类型，并且结果也是int类型。

Java提供了两个用于高精度计算类：BigInteger和BigDecimal，大体属于“包装器类”范畴，但都没有对应的基本类型。

BigInteger支持任意精度的整数，可表示任何大小的整数值。

BigDecimal支持任意精度的定点数，例如，可以用它进行精确的货币计算。

###引用与对象生存周期

```
{

       String s = new String("a string");

}
```

引用s在作用域终点就消失了，然而，s指向的String对象继续占据内存，最后由垃圾回收器回收。

###方法签名

方法名和参数列表（合起来被称为“方法签名”）唯一地标识出某个方法。

###static修饰字段与方法的区别

一个static字段对每个对象来说都只有一份空间，而非static字段则是对每个对象都有一个存储空间，但是如果static作用于某个方法时，差别却没有那么大，static方法的一个重要的用法就是在不创建任何对象的前提下就可以调用它，这一点对定义main()方法很重要，该方法是运行时程序的一个入口。


